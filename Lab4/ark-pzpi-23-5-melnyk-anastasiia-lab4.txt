МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з лабораторної роботи № 4 з дисципліни
Аналіз та рефакторинг коду










Виконала:                                                                Перевірив:
ст. гр. ПЗПІ-23-5                				ст. викладач кафедри ПІ
Мельник Анастасія					Сокорчук Ігор Петрович
	




















Харків 2025

1 ІСТОРІЯ ЗМІН
      №
      Дата
Версія звіту
Опис змін та виправлень
      1
      01.01.2026
      0.1
      Початкова версія

      




2 ЗАВДАННЯ

1. Розробити будову програмного забезпечення ІоТ клієнта.
2. Створити UML діаграму прецедентів для ІоТ клієнта.
3. Розробити бізнес логіку (математину обробку повʼязаних із предметною областю даних) та функції налаштування ІоТ клієнта.
4. Створити діаграму діяльності для ІоТ клієнта.
5. Створити програмну реалізацію бізнес логіки та функцій налаштування ІоТ клієнта.
6. Перевірити роботу ІоТ клієнта.
7. Завантажити або оновити (при потребі) створений програмний код у GitHub репозиторій для лабораторних робіт у гілку репозиторію main.
8. Створити відеозапис демонстрації описаної у розділі 3.1 Vision & Scope. функціональності IoT клієнта та завантажити цей відеозапис у свій канал на YouTube. При завантаженні відеозапису потрібно обовʼязково встановити у налаштуваннях для цього відео українську мову як мову відео та мову субтитрів до відео.
9. Створити хронологічний опис (хвилина:секунда) демонстрації та додати цей опис до опису відео.
10. Створити звіт до лабораторної роботи.
11. Експортувати створений звіт у формат PDF та завантажити його на платформу dl.nure.ua.
12. Експортувати увесь створений звіт у текстовий файл з кодуванням UTF-8 та записати цей файл у GitHub репозиторій для лабораторних робіт.


3 ОПИС ВИКОНАНОЇ РОБОТИ

	
     Уся система є комплексною програмною моделлю реальної IoT-екосистеми, побудованої за принципами, які використовуються у промислових, аграрних та «розумних» побутових рішеннях, і вона демонструє повний життєвий цикл даних від моменту їхнього збирання на сенсорі до аналізу, фільтрації та передачі у серверну інфраструктуру. 
     Починається все з віртуального середовища PlantEnvironment (див. дод. В, sensors.py), яке відіграє роль фізичного світу: воно не просто зберігає числові значення параметрів, а моделює їхню еволюцію у часі з урахуванням закономірностей природи. Освітлення змінюється відповідно до добового циклу, вдень його інтенсивність наростає і спадає плавно, що імітує рух сонця по небосхилу, а вночі зводиться майже до нуля; температура реагує на цей цикл із запізненням, як це відбувається у реальному середовищі, де нагрів і охолодження мають теплову інерцію; вологість повітря обчислюється як функція температури і додатково обмежується фізично можливими межами; вологість ґрунту зменшується через випаровування, яке посилюється при високій температурі та яскравому світлі, і зрідка різко зростає, імітуючи втручання людини або автоматичної системи поливу; рівень батареї зменшується дуже повільно, що відповідає енергоспоживанню автономного сенсорного вузла. Кожна з цих величин змінюється не ідеально, а з невеликим випадковим шумом, що дозволяє перевіряти алгоритми обробки даних у умовах, близьких до реальних, де сенсори ніколи не дають абсолютно стабільних показників. 
     Поверх цього середовища побудована абстракція сенсорів (див. дод. В, sensors.py), де кожен сенсор є окремим класом, відповідальним лише за читання конкретного параметра і форматування результату, що реалізує принцип єдиної відповідальності та спрощує підтримку коду. Віртуальний пристрій збирає дані з усіх сенсорів у певному інтервалі часу і публікує їх через MQTT, що дозволяє імітувати роботу реального пристрою з обмеженими ресурсами, який передає дані невеликими повідомленнями у брокер. 
     MQTT сенсорів (див. дод. В, mqtt_manager.py) відіграє ключову роль як транспортний рівень, що забезпечує асинхронну, масштабовану та енергоефективну доставку повідомлень від багатьох пристроїв до центрального вузла, при цьому структура топіків із використанням MAC-адреси дозволяє легко ідентифікувати джерело кожного повідомлення та розширювати систему без зміни існуючої логіки. MQTT-міст, виступає точкою консолідації даних і водночас фільтром всієї системи: він не лише ретранслює показники у зовнішній API, а й аналізує кожне значення за допомогою AnomalyDetector, який є центром аналітичної частини. Цей детектор реалізує підхід, орієнтований не на жорсткі пороги, а на адаптивну статистику, що дозволяє системі підлаштовуватися під індивідуальні особливості кожного пристрою і кожного типу сенсора. 
     Для кожної комбінації MAC-адреса – тип сенсора ведеться власна історія значень, яка зберігається у файлі, що забезпечує довготривалу пам’ять системи і робить аналіз більш стабільним у часі. На початковому етапі система перебуває у режимі калібрування, накопичуючи дані без винесення рішень, а після досягнення мінімального обсягу історії обчислює квартилі, міжквартильний розмах, медіану та ефективні межі допустимих значень з урахуванням мінімального IQR (див. дод. В, anomaly_detector.py), спеціально підібраного для кожного типу сенсора, щоб уникнути хибних спрацьовувань при дуже стабільних даних. 
     Така гнучка конфігурація дозволяє коректно реагувати на різкі, але природні зміни освітленості, не вважаючи їх аномаліями, і водночас фіксувати навіть невеликі, але нетипові відхилення температури чи вологості, які можуть свідчити про несправність обладнання або небезпечні умови для рослини. Усі виявлені аномалії детально логуються, що створює основу для побудови систем сповіщення, аналітичних панелей або машинного навчання на вищому рівні. 
     Завершальним елементом архітектури є скрипт-лаунчер, який координує запуск усіх компонентів, забезпечує коректну роботу системи в режимі емуляції і дозволяє легко відтворювати сценарії для демонстрацій, тестування або навчальних лабораторних робіт. 


4 ВИСНОВКИ
     
     У результаті виконання лабораторної роботи було створено повноцінну модульну IoT-систему, яка включає емуляцію фізичного середовища, сенсорів, MQTT-передачу даних та детекцію аномалій.
     Розроблена система моделює реальні умови росту рослин у віртуальному середовищі PlantEnvironment, враховуючи цикли освітлення, температуру, вологість ґрунту та повітря, а також рівень заряду батареї. Використання випадкового шуму дозволяє тестувати алгоритми обробки даних у сценаріях, наближених до реальних.
     Абстракція сенсорів забезпечує принцип єдиної відповідальності: кожен сенсор відповідає за свій параметр, що спрощує масштабування та підтримку коду. VirtualPlantSensor збирає дані з усіх сенсорів та формує готові показники для подальшої обробки.
     Передача даних здійснюється через MQTT, що забезпечує асинхронну, масштабовану та енергоефективну доставку показників до центрального вузла. Bridge відповідає за консолідацію даних, перевірку на аномалії за допомогою AnomalyDetector та передачу на API. Модуль аномалій реалізує статистичний підхід із використанням міжквартильного розмаху (IQR), адаптивних меж та медіани, що дозволяє виявляти нетипові значення без хибних спрацювань.
     Архітектура системи є модульною, масштабованою та гнучкою, що дозволяє легко додавати нові сенсори, змінювати параметри аномалій та інтегрувати систему з реальними IoT-пристроями.






ДОДАТОК А

Відеозапис 

Відеозапис презентації результатів лабораторної роботи: 
https://youtu.be/9e3itG6a7UM

Хронологічний опис відеозапису:




ДОДАТОК Б

Графічні матеріали


Рисунок 1 — Діаграма прецедентів ІоТ клієнта







Рисунок 2 — Діаграма діяльності ІоТ клієнта



















ДОДАТОК В

Anomaly_detector.py
1. import json
2. import os
3. import statistics
4. 
5. class AnomalyDetector:
6.     def __init__(self, history_file='sensor_history.json', history_size=20, multiplier=2):
7.         self.history_file = history_file
8.         self.history_size = history_size
9.         self.base_multiplier = multiplier 
10.         self.data = self._load_data()
11. 
12. 
13.         self.SENSOR_CONFIG = {
14.           
15.             'LIGHT_INTENSITY': {'min_iqr': 300, 'multiplier': 4.0}, 
16.            
17.             'SOIL_MOISTURE':   {'min_iqr': 15,   'multiplier': 3.0}, 
18.            
19.             'AIR_TEMPERATURE': {'min_iqr': 2,    'multiplier': 3.0},
20.           
21.             'AIR_HUMIDITY':    {'min_iqr': 5,    'multiplier': 3.0},
22.        
23.             'BATTERY_LEVEL':   {'min_iqr': 1,    'multiplier': 5.0}
24.         }
25. 
26.     def _load_data(self):
27.         if os.path.exists(self.history_file):
28.             try:
29.                 with open(self.history_file, 'r') as f:
30.                     return json.load(f)
31.             except (json.JSONDecodeError, ValueError):
32.                 return {}
33.         return {}
34. 
35.     def _save_data(self):
36.         with open(self.history_file, 'w') as f:
37.             json.dump(self.data, f, indent=2)
38. 
39.     def _get_params(self, sensor_type):
40.         cfg = self.SENSOR_CONFIG.get(sensor_type, {'min_iqr': 10, 'multiplier': self.base_multiplier})
41.         return cfg['min_iqr'], cfg['multiplier']
42. 
43.     def check_and_update(self, mac, sensor_type, value):
44.         if mac not in self.data:
45.             self.data[mac] = {}
46.         if sensor_type not in self.data[mac]:
47.             self.data[mac][sensor_type] = []
48. 
49.         history = self.data[mac][sensor_type]
50.         is_anomaly = False
51.         message = "Normal"
52.         median_val = value
53. 
54.         min_iqr, current_multiplier = self._get_params(sensor_type)
55.         if len(history) < 5:
56.             self._update_history(mac, sensor_type, value)
57.             return False, "Calibrating (gathering history...)", value
58. 
59.         try:
60.             quartiles = statistics.quantiles(history, n=4)
61.             q1 = quartiles[0] 
62.             q3 = quartiles[2] 
63.             
64.             iqr = q3 - q1
65.             median_val = quartiles[1] 
66. 
67.             effective_iqr = max(iqr, min_iqr)
68.             margin = current_multiplier * effective_iqr
69.             lower_bound = q1 - margin
70.             upper_bound = q3 + margin
71. 
72.             if value < lower_bound or value > upper_bound:
73.                 is_anomaly = True
74.                 message = (
75.                     f"IQR Anomaly! Value {value} outside "
76.                     f"[{lower_bound:.2f} ... {upper_bound:.2f}]. "
77.                     f"Median: {median_val:.2f}, Used IQR: {effective_iqr}"
78.                 )
79. 
80.         except Exception as e:
81.             message = f"Calculation error: {e}"
82. 
83.         self._update_history(mac, sensor_type, value)
84.         
85.         return is_anomaly, message, median_val
86. 
87.     def _update_history(self, mac, sensor_type, value):
88.         history = self.data[mac][sensor_type]
89.         history.append(value)
90.         if len(history) > self.history_size:
91.             history.pop(0)
92.         self.data[mac][sensor_type] = history
93.         self._save_data()

Bridge.py
1. import paho.mqtt.client as mqtt
2. import requests
3. import json
4. import logging
5. import sys
6. import time
7. from config import MQTT_BROKER, MQTT_PORT, TOPIC_PREFIX, API_ENDPOINT, MQTT_USERNAME, MQTT_PASSWORD
8. from anomaly_detector import AnomalyDetector
9. 
10. 
11. logging.basicConfig(
12.     level=logging.INFO,
13.     format='%(asctime)s [BRIDGE] %(message)s',
14.     datefmt='%H:%M:%S',
15.     handlers=[logging.StreamHandler(sys.stdout)]
16. )
17. 
18. detector = AnomalyDetector(history_file='sensor_history.json', history_size=20, multiplier=3)
19. 
20. def on_connect(client, userdata, flags, rc):
21.     if rc == 0:
22.         logging.info(f"Bridge Connected to Broker ({MQTT_BROKER})")
23.         topic = f"{TOPIC_PREFIX}/+/readings"
24.         client.subscribe(topic)
25.         logging.info(f" Listening to topic: {topic}")
26.     else:
27.         logging.error(f" Connection failed: code {rc}")
28. 
29. def on_message(client, userdata, msg):
30.     try:
31.         payload_str = msg.payload.decode()
32.         mqtt_payload = json.loads(payload_str)
33.         
34.         mac = mqtt_payload.get('macAddress', 'UNKNOWN')
35.         r_type = mqtt_payload.get('type', 'UNKNOWN')
36.         val = mqtt_payload.get('value', 0)
37. 
38.         is_anomaly, anomaly_msg, mean_val = detector.check_and_update(mac, r_type, val)
39. 
40.         if is_anomaly:
41.             log_msg = (
42.                 f"\033[  ANOMALY DETECTED [{mac}] {r_type}: {val}\n"
43.                 f"    Mean: {mean_val:.2f} | {anomaly_msg}\033[0m"
44.             )
45.             logging.warning(log_msg)
46.         else:
47.             status_note = "(Calibrating)" if "Calibrating" in anomaly_msg else "(OK)"
48.             logging.info(f" MQTT Recv [{mac}]: {r_type} = {val} {status_note}")
49. 
50.         api_payload = {
51.             "macAddress": mac,
52.             "type": r_type,
53.             "value": val,
54.         }
55. 
56.         response = requests.post(API_ENDPOINT, json=api_payload, timeout=2)
57. 
58.         if response.status_code in [200, 201]:
59.             if is_anomaly:
60.                 logging.info(f"Forwarded to API (Logged as Anomaly)")
61.         elif response.status_code == 404:
62.             logging.warning(f"Server Warning: Device not registered")
63.         else:
64.             logging.error(f"Server Error {response.status_code}: {response.text}")
65. 
66.     except requests.exceptions.ConnectionError:
67.         logging.error(f"API Connection Failed! Is server running at {API_ENDPOINT} ?")
68.     except Exception as e:
69.         logging.error(f"Processing Error: {e}")
70. 
71. def main():
72.     logging.info("Starting Smart Bridge")
73.     logging.info(f"Target API: {API_ENDPOINT}")
74. 
75.     client = mqtt.Client()
76.     
77.     if MQTT_USERNAME and MQTT_PASSWORD:
78.         client.username_pw_set(MQTT_USERNAME, MQTT_PASSWORD)
79. 
80.     client.on_connect = on_connect
81.     client.on_message = on_message
82. 
83.     try:
84.         logging.info("Connecting to broker")
85.         client.connect(MQTT_BROKER, MQTT_PORT, 60)
86.         client.loop_forever()
87.     except KeyboardInterrupt:
88.         logging.info("\nBridge stopped by user.")
89.     except Exception as e:
90.         logging.error(f"Critical Error: {e}")
91. 
92. if __name__ == "__main__":
93.     main()


Mqtt_manager.py
1. import paho.mqtt.client as mqtt
2. import json
3. import time
4. import logging
5. 
6. class MqttPublisher:
7.     def __init__(self, broker, port, topic_prefix, device_mac):
8.         self.client = mqtt.Client()
9.         self.broker = broker
10.         self.port = port
11.         self.topic_prefix = topic_prefix
12.         self.device_mac = device_mac
13.         
14.         self.client.on_connect = self.on_connect
15. 
16.     def on_connect(self, client, userdata, flags, rc):
17.         if rc == 0:
18.             logging.info(f"Device Connected to Broker: {self.broker}")
19.         else:
20.             logging.error(f"Connection failed: {rc}")
21. 
22.     def connect(self):
23.         self.client.connect(self.broker, self.port, 60)
24.         self.client.loop_start()
25. 
26.     def publish_reading(self, reading_type, value):
27.         topic = f"{self.topic_prefix}/{self.device_mac}/readings"
28.         
29.         payload = {
30.             "macAddress": self.device_mac,
31.             "type": reading_type,
32.             "value": value,
33.             "timestamp": time.time()
34.         }
35.         
36.         self.client.publish(topic, json.dumps(payload))
37.         logging.info(f"MQTT Sent: {reading_type}={value} -> {topic}")
38. 
39.     def disconnect(self):
40.         self.client.loop_stop()
41.         self.client.disconnect()

Sensor.py
1. import random
2. import time
3. import math
4. 
5. class PlantEnvironment:
6.     def __init__(self):
7.         self.soil_moisture = 60.0
8.         self.battery_level = 100.0
9.         self.temperature = 22.0
10.         self.humidity = 60.0
11.         self.light_level = 0.0
12.         self.start_time = time.time()
13.         
14.     def update(self):
15.         elapsed_real_seconds = time.time() - self.start_time
16.         sim_minutes_passed = elapsed_real_seconds * 10 
17.         cycle_position = (sim_minutes_passed % 1440) / 60.0 
18.     
19.         if 6 <= cycle_position <= 20:
20.             day_progress = (cycle_position - 6) / 14 * math.pi
21.             base_light = math.sin(day_progress) * 1000
22.         else:
23.             base_light = 0
24.             
25.         cloud_cover = random.uniform(0.8, 1.2)
26.         self.light_level = max(0, base_light * cloud_cover)
27. 
28.         temp_cycle = math.sin((cycle_position - 9) / 24 * 2 * math.pi)
29.         target_temp = 22 + (temp_cycle * 5)
30.         self.temperature += (target_temp - self.temperature) * 0.05
31.         self.temperature += random.uniform(-0.05, 0.05)
32. 
33.         target_humidity = 80 - (self.temperature - 15) * 2.5
34.         self.humidity += (target_humidity - self.humidity) * 0.1
35.         self.humidity = max(30, min(100, self.humidity + random.uniform(-1, 1)))
36. 
37.         evaporation_rate = 0.001 + (self.temperature / 1000) + (self.light_level / 20000)
38.         self.soil_moisture -= evaporation_rate
39.     
40.         if self.soil_moisture < 25 and random.random() < 0.1:
41.             self.soil_moisture += random.uniform(30, 50)
42. 
43.         self.soil_moisture = max(0, min(100, self.soil_moisture))
44. 
45.         self.battery_level = max(0, self.battery_level - 0.002)
46. 
47. 
48. 
49. 
50. class Sensor:
51.     def __init__(self, environment: PlantEnvironment):
52.         self.env = environment
53. 
54.     def read(self) -> dict:
55.         raise NotImplementedError("Method 'read' must be implemented")
56. 
57. class MoistureSensor(Sensor):
58.     def read(self):
59.         return {"type": "SOIL_MOISTURE", "value": round(self.env.soil_moisture, 2)}
60. 
61. class TemperatureSensor(Sensor):
62.     def read(self):
63.         return {"type": "AIR_TEMPERATURE", "value": round(self.env.temperature, 2)}
64. 
65. class HumiditySensor(Sensor):
66.     def read(self):
67.         return {"type": "AIR_HUMIDITY", "value": round(self.env.humidity, 2)}
68. 
69. class LightSensor(Sensor):
70.     def read(self):
71.         return {"type": "LIGHT_INTENSITY", "value": round(self.env.light_level, 2)}
72. 
73. class BatterySensor(Sensor):
74.     def read(self):
75.         return {"type": "BATTERY_LEVEL", "value": round(self.env.battery_level, 2)}
76. 
77. 
78. class VirtualPlantSensor:
79.     def __init__(self):
80.         self.environment = PlantEnvironment()
81.    
82.         self.sensors = [
83.             MoistureSensor(self.environment),
84.             TemperatureSensor(self.environment),
85.             HumiditySensor(self.environment),
86.             LightSensor(self.environment),
87.             BatterySensor(self.environment)
88.         ]
89. 
90.     def get_readings(self):
91.         self.environment.update()
92.         readings = []
93.         for sensor in self.sensors:
94.             readings.append(sensor.read())
95.             
96.         return readings
2


